# Искусство README

## Происхождение

Как, когда и где появился термин "README"?

Первое упоминание относится к, как минимум, 1970-м годам [и
PDP-10] (http://pdp-10.trailing-edge.com/decuslib10-04/01/43,50322/read.me.html),
хотя на самом деле, скорее отсылает нас в дни информативных бумажных заметок, возвышающихся 
над стеком перфокарт, с нацарапанным "READ ME!" на них, описывавших использование этих перфокарт.

Читатель может предполодить<sup>[1](#footnote-1)</sup>, что название README может быть отсылкой к "Приключениям Алисы 
в Стране Чудес" Льюиса Кэрола, где были бутылочка и пирог, с надписями "Выпей меня" и "Съешь меня" соответственно.

Надпись README, состоящая из всех заглавных букв является лишь одной из особенностей.
В дополнение к заметности самой фразы, написанной всеми заглавными буквами,
у такой надписи есть еще одна примечательная черта - UNIX-системы помещают слова, начинающиеся с заглавных букв, 
наверх списка при сортировке. Таким образом, файл с названием README
(состоящим из всех заглавных букв), окажется в начале списка <sup>[2](#footnote-2)</sup>.

Посыл прост и понятен - это важная информация, с которой необходимо ознакомиться прежде,
чем продолжить работу. Давайте разберемся, что представляет собой "важная информация "в наш век информационных технологий.


## Для создателей, для потребителей

Это статья о файлах README. О том, что они делают, почему они так необходимы,
и как правильно их готовить.

Это написано для создателей различных модулей, ибо, как создатель модулей, ваша работа состоит в том, чтобы
создать что-то, что будет существовать долго и счастливо. Это должно быть вашей мотивацией, даже если вы, как автор,
не имеете никакого желания делиться своей работой. Пройдет полгода, и написанный вами модуль покажется вам совершенно 
непонятным и незнакомым, просто потому, что человеку свойственно забывать неиспользуемую информацию.

Это важно и для тех, кто пользуется модулем. В конечном счете,
каждый автор чего-либо является и пользователем. Никто из нас не может
похвастаться абсолютной независимостью - мы все используем
в нашей работе что-то, уже созданное до нас.

Все вышесказанное верно для абсолютно всех языков программирования.


## Модули бывают разные: плохие и хорошие

Экосистема nodejs подпитывается своими модулями. [npm] (https://npmjs.org) - это
магия, которая заставляет все это работать. В течение недели, разработчики оценивают
десятки модулей для включения их в свои проекты. Все вместе - очень мощный инструмент,
который может быть развернут и использован так же быстро, как вы напишете в консоли `npm install`.

Как и у любой экосистемы, которая является общедоступной, качество модулей может сильно варьироваться. npm делает все возможное, чтобы все эти модули были доступны каждому. Тем не менее, эти инструменты сильно разнятся: некоторые из них новые и отлично работают, другие не работают, а третьи находятся где-то посередине. Есть и такие, о которых мы вообще не знаем, зачем они нужны.

Для модулей, это может принимать форму неточных или бесполезных имен (кто нибудь может сказать, что делает модуль `fudge`?), отсутствия  документации, тестов, отсутствие комментариев в исходном коде или непонятные имена функций.

Многие из них не имеют активного сопровождающего. Если модуль нет человека, способного 
ответить на вопросы и объяснить, что делает модуль, в сочетании с отсутствием какой-либо
документация, модуль превращается в странный инопланетный артефакт, непригодный для использования и непонятный вообще никому.

А что касается тех модулей, у которых есть какая-нибудь документация? Может быть, это просто описание в одну строку: `" числа сортируются по их шестнадцатиричному коду "`. Может быть, это фрагмент кода примера.
Это уже лучше чем ничего, но тоже приводит к худшему сценарию - копание в исходном коде, с единственной целью - понять, как же все-таки оно работает. Написание превосходной документации позволит не подпускать будущих пользователей к исходным кодам, позволит им в полной мере насладиться удобством использования вашего модуля. А как оно устроено внутри - 
им, пользователям, уже не важно.

Вся экосистема состоит из нескончаемого списка простых модулей, делающих одну единственную вещь, и никакую другую.
Есть [исключения] (https://github.com/lodash/lodash), но они покрывают очень малую часть экосистемы.

Из этого следует простой вывод - найти действительно хороший модуль, который делает то, что тебе нужно, может быть действительно сложной задачей.

И это нормально. Гораздо лучше иметь не очень высокую входную планку и понимание происходящего,
чем иметь очень маленькое сообщество, в жизни которого могут принимать участие единицы.

Плюс ко всему, чем непонятнее что-либо - тем важнее обратиться за помощью.


## Все дороги ведут к README.txt

Сообщество Nodejs ответило на вызов понятности различными способами.

Некоторые опытные разработчики на Nodejs объединились, чтобы создать [рекомендованные  списки]
(https://github.com/sindresorhus/awesome-nodejs) качественных модулей.

Разработчики использовали их несколько лет, проверили сотни и тысячи модулей,
чтобы поделиться с новичками самыми сливками: в каждой категории только лучшие модули.
Это приняло форму RSS-ленты и e-mail рассылки со списками новых модулей, признаных
полезными различными опытными членами сообщества.

Как насчет социального графа? Эта идея привела к созданию
[Node-modules.com] (http://node-modules.com/), замене npm-поиска, которая
использует ваш социальный граф  на Github  чтобы найти модули, которые нравятся
вашим друзьям или были ими сделаны.

Конечно же есть и [поиск] (https://npmjs.org), встроенный в npm:
безопасный и являющийся точкой входа для всех новых разработчиков.

Независимо от того какой подход вам больше нравится,
и не смотря на то где ищущий модули в конечном счете
находит себя: на [npmjs.org] (https://npmjs.org) или
[Github.com] (https://github.com) или где-то еще,
абсолютно все будут читать ваш README. И раз уж до README все равно добрались,
то как сделать его максимально полезным для конечного пользователя?

-----
###### ДАЛЬНЕЙШИЙ ТЕКСТ - ПЕРЕВОД ГУГЛА, НИКАК НЕ РЕДАКТИРОВАЛСЯ!!!!
-----

## Профессиональный искатель модулей

### README: Ваш универсальный магазин

README является первым, на что смотрит пользователь модуля - и, возможно, только - смотреть в твои
создание. Потребитель хочет модуль, чтобы выполнить свои потребности, так что вы должны объяснить,
именно то, что нужно ваш модуль заполняет, и насколько эффективно это делает так.

Ваша задача заключается в

1. скажите им, что это такое (с контекстом)
2. показать им, что это выглядит в действии
3. показать им, как они используют его
4. сказать им любые другие соответствующие детали

Это * ваша * работа. Это до модуля создателя, чтобы доказать, что их работа является
блестящий драгоценный камень в море небрежным модулей. Так как очень многие разработчики глаза подставляется
найти свой путь к вашему README, прежде чем что-либо другое, качество здесь ваш
общественного лицом мера вашей работы.


### Краткость

Отсутствие README является мощным красный флаг, но даже длительный README не
Показательно, чтобы там быть высокого качества. Идеальный README должен быть максимально коротким, как он может
быть без какой-либо короче. Подробная документация хороша - сделать отдельный
страницы для этого! - Но сохранить ваш README лаконичным.


### Учитесь прошлым

Говорят, что те, кто не изучает их историю, обречены сделать его
ошибки снова. Разработчики писали документацию для некоторого числа
лет. Было бы расточительно не оглянуться немного и посмотреть, что люди
сделал прямо перед Node.

Perl, для всех зенитки он получает, в некотором смысле духовного прародителя
узла. Оба являются языки сценариев на высоком уровне, принять много идиомы UNIX, топливо
большая часть Интернета, и оба имеют широкий модуль экосистемы.

Так получается, что [монахи] (http://perlmonks.org) сообщества Perl
действительно имеют большой опыт в письменной форме [качество
Файлы README] (http://search.cpan.org/~kane/Archive-Tar/lib/Archive/Tar.pm). CPAN является
замечательный ресурс, который стоит читать через, чтобы узнать больше о сообществе
что писал стабильно высокого калибра документации.


### Нет README? Нет абстракции

Ни один README не означает, что разработчикам нужно будет вникать в код для того, чтобы
понимать это.

Монахи Perl есть мудрость, чтобы поделиться по этому вопросу:

> Ваша документация будет завершена, когда кто-то может использовать модуль без когда-либо
> Того, чтобы посмотреть на его код. Это очень важно. Это делает возможным для
> Отделить документированный интерфейс вашего модуля от его внутренней
> Реализации (кишок). Это хорошо, потому что это означает, что вы свободны
> Изменить внутренности модуля, до тех пор пока интерфейс остается неизменным.
>
> Помните: документация, а не код, определяет то, что делает модуль.
- [Кен Уильямс] (http://mathforum.org/ken/perl_modules.html#document)


### Ключевые элементы

После того, как README расположен, храбрый модуль спелеолог должен проверить его распознать, если
он соответствует потребностям разработчика. Это становится по существу ряд узора
сопоставив проблемы для их мозга, чтобы решить, где каждый шаг берет их глубже
в модуль и его детали.

Скажем, к примеру, мой поиск модуля обнаружения столкновений 2D приводит меня
к [ `соударяются-2d-Аабб-aabb`] (https://github.com/noffle/collide-2d-aabb-aabb). я
начинают рассматривать его сверху вниз:

1. * Имя * - самоочевидные названия являются лучшими. `Collide-2d-AABB-aabb` звуки
   многообещающим, хотя он предполагает, я знаю, что такое "AABB" есть. Если имя звучит слишком
   расплывчаты или не связаны, это может быть сигналом, чтобы двигаться дальше.

2. * One-вкладыш * - имеющий один вкладыш, который описывает модуль полезен для
   получить представление о том, что модуль делает в немного более подробно.
   `Сталкиваются-2d-AABB-aabb` говорит, что это

   > Определяет, сталкивается ли перемещение по оси выровнен ограничивающего прямоугольника (AABB) с
   > другие AABBs.

   Высокий: он определяет, что такое ААББ есть, и то, что модуль делает. Теперь, чтобы оценить, насколько
   хорошо было бы вписаться в мой код:

3. * Использование * - а не начинать вникать в API Docs, было бы здорово
   увидеть, что модуль выглядит в действии. Я могу быстро определить, является ли
   Пример JS подходит желаемый стиль и проблемы. У людей есть много мнений
   на такие вещи, как обещания / обратных вызовов и ES6. Если это не соответствует законопроект, то я
   может перейти к более подробно.

4. * API * - название, описание и использование этого модуля все звуковой привлекательной
   мне. Я очень вероятно, использовать этот модуль в этой точке. Мне просто нужно сканировать
   API-интерфейс, чтобы убедиться, что он делает именно то, что мне нужно, и что она будет интегрировать
   легко в мой код. Раздел API должен подробно объекты модуля
   и функции, их подписи, типы возвращаемых значений, обратные вызовы и события в хорошем
   подробно. Типы должны быть включены, если они не очевидны. Предостережения должны быть
   ясно.

5. * Установка * - если я прочитал это далеко вниз, то я продал на опробовать
   модуль. Если есть нестандартные указания по монтажу, вот где они идут,
   но даже если это просто обычный `НПМ install` Я хотел бы иметь, что перечисленные
   слишком. Новые пользователи начинают использовать Сев.Узел все время, так что наличие ссылки на npmjs.org
   и команды установки помогает то, что пользователь с ресурсами, чтобы выяснить, как Node
   модули работают.

6. * Лицензия * - большинство модулей положить это в самом низу, но это может
   на самом деле лучше иметь выше; вы, вероятно, чтобы исключить модуль ОЧЕНЬ
   быстро, если это имеет несовместимую лицензию на вашу работу. Я вообще придерживаться
   ароматы MIT / BSD / X11 / ISC. Если у вас есть непермиссивной лицензию, придерживаться его
   на самом верху модуля, чтобы предотвратить путаницу


## Когнитивная утекают

Упорядочение выше, не был выбран случайным образом.

потребители модулей используют множество модулей, и нужно смотреть на многих модулей.

После того, как вы посмотрели на сотни модулей вы начинаете замечать, что ум
выгоды от предсказуемый характер.

Вы также начать строить свой собственный личный эвристики для какую информацию вы
хотите, и какие красные флаги дисквалифицировать модули быстро.

Таким образом, отсюда следует, что в README желательно иметь:

1. предсказуемый формат
2. некоторые ключевые элементы присутствуют

Вам не нужно использовать * этот формат *, но стараюсь быть последовательным, чтобы сохранить пользователей
драгоценные познавательные циклы.

Упорядочение представленная здесь любовно называют "когнитивным утекают",
и можно представить себе в виде воронки в вертикальном положении, где самый широкий конец содержит
Широчайшие более важные детали, и перемещение глубже в воронку подарки
более конкретные детали, которые уместны только для читателя, который интересуется
достаточно в своей работе, что глубоко, что достигнуто в документе. И, наконец,
дно может быть зарезервирован для деталей, которые только те, заинтригованы тем глубже
контекст работы (фон, кредиты, Библио, ...)

Опять же, монахи Perl есть мудрость, чтобы делиться на эту тему:

> Уровень детализации в документации модуля Perl как правило, идет от
> Менее подробные, чтобы более детально. Ваш СИНТАКСИС раздел должен
> Содержит минимальный пример использования (возможно, всего лишь одной линии
> Код; пропустить необычные случаи использования или что-нибудь не нужны большинством
> пользователей); Описание должно описать свой модуль в широком смысле,
> Как правило, в несколько пунктов; более подробно модуля
> процедуры или методы, длинные примеры кода, или другие в глубины
> Материал должен быть приведен в последующих разделах.
>
> В идеале, кто-то, кто немного знаком с модулем должен быть
> Возможность освежить в памяти без нажатия на клавишу "страницу вниз". Как ваш
> Читатель продолжает через документ, они должны получать
> Прогрессивно большее количество знаний. - От `perlmodstyle`


## Забота о времени людей

Потрясающие; упорядочение этих ключевых элементов должны определяться, как быстро
они позволяют кому-то «короткое замыкание» и под залог Вашего модуля.

Это звучит мрачно, не так ли? Но думать об этом: ваша работа, когда вы делаете
она с оптимальным альтруизма в виду, не "продать" людей на работе. Это в
пусть оценить то, что ваше творение делает настолько объективно, насколько это возможно, и решить,
отвечает ли она их потребности или нет. Не, скажем, увеличить ваши загрузки или
UserBase.

Такое мышление не обращается к каждому; она требует проверки вашего эго на
дверь и позволить работу говорить за себя как можно больше. Ваша единственная работа
чтобы описать свое обещание, как сжато, как вы можете, так что модуль спелеологи может
либо использовать вашу работу, когда это нужным, или двигаться дальше к чему-то другому, что делает.


## Бонус: другие хорошие практики

Вне ключевых моментов статьи, существуют и другие методы вы можете
следовать (или не следовать), чтобы поднять планку качества вашего README еще дальше, и
максимизировать свою полезность для других.

1. рассмотреть вопрос о включении ** ** Фон раздел, если ваш модуль зависит от того,
   важно, но не так широко известных абстракциями или других экосистем. Функция
   из [ `рассекает-between`] (https://github.com/noffle/bisecting-between) не
   сразу видно из его названия, поэтому она подробный * Фон * раздел
   определить и ссылку на больших понятий и абстракций нужно
   понимать и использовать его обращал внимания. Это также отличное место, чтобы объяснить
   мотивация модуля, если аналогичные модули уже существуют на НПМ.

2. Агрессивно linkify! Если говорить о других модулях, идей или людей, сделать
   что текст ссылки ссылку, так что посетители могут более легко обращал внимания на свой модуль
   и идеи он опирается. Немногие модули существуют в вакууме: вся работа идет
   от другой работы, поэтому он платит, чтобы помочь пользователям следовать за историю вашего модуля и
   вдохновение.

3. Включить информацию о типах аргументов и возвращаемых параметров, если это не
   очевидно. Предпочитают конвенции, где это возможно ( `cb`, вероятно, означает обратный вызов
   функция, `num`, вероятно, означает` Number`).

4. Включите пример кода в ** Использование ** в виде файла в вашем репо - может быть, как
   `Example.js`. Это здорово иметь README код, который пользователи могут реально работать, если
   они клонировать репозиторий.

5. Будьте рассудительным в вашем использовании значков. Они легко
   [Злоупотребление] (https://github.com/angular/angular). Они также могут быть питательной
   Основанием для bikeshedding и бесконечных споров. Они добавляют визуальный шум к вашему
   README, и как правило, только функция, если пользователь читает ваш уценки в
   браузер в Интернете, так как образы, как правило, размещается в другом месте на
   Интернет. Для каждого знака, рассмотреть следующие вопросы: "что реальное значение этот значок обеспечивая
   к типичным зрителем этого README "? Есть CI значок, чтобы показать сборки / тест
   положение дел? этот сигнал будет лучше добраться до важных партий по электронной почте
   Сопровождающие или автоматически создавая проблему - всегда считают
   аудитория данных в вашем README и спросите себя, если есть поток для
   что данные, которые могут лучше достичь своей целевой аудитории.

6. API форматирования является весьма bikesheddable. Используйте любой формат, который вы считаете наиболее
   ясно, но убедитесь, что ваш формат выражает важные тонкости:

   а. какие параметры не являются обязательными, и их значения по умолчанию

   б. говоря информацию о типе, где это не очевидно из конвенции

   гр. для `opts` параметров объекта, подробно описать все ключи и значения, которые принимаются

   d. не уклоняться от предоставления крошечный пример использования API функцию, если
      их использование не является очевидным или полностью покрыты в ** Использование ** раздела.
      Тем не менее, это также может быть сильным сигналом, что функция слишком сложна
      и должен быть переработан, разбиты на более мелкие функции, или удалены
      в целом

   е. агрессивно linkify специализированную терминологию! В уценки вы можете сохранить
      [Сноски] (https://daringfireball.net/projects/markdown/syntax#link) в
      в нижней части документа, поэтому обращаясь к ним несколько раз в течение
      становится дешевым. Некоторые из моих личных предпочтений по апи форматирования может быть
      найденный
      [Здесь] (https://github.com/noffle/common-readme/blob/master/api_formatting.md)

7. Если ваш модуль представляет собой небольшой набор функций без гражданства, имеющие
   ** Использование ** раздел как [Node РЕПЛ
   сессия] (https://github.com/noffle/bisecting-between#example) функции
   вызовы и результаты могут общаться использование более ясно, чем исходный код
   файл для запуска.

8. Если ваш модуль обеспечивает CLI (интерфейс командной строки) вместо (или в
    дополнение) программный API, показывают примеры использования в качестве командных вызовов
    и их вывод. если вы создаете или изменить файл, `cat` его, чтобы продемонстрировать
    изменение до и после.

9. Не забывайте использовать `package.json`
    [Ключевые слова] (https://docs.npmjs.com/files/package.json#keywords) направить
    модуль спелеологи к вашему порогу.

10. Чем больше вы изменить свой API, тем больше работы вам необходимо приложить обновления
    документация - Смысл заключается в том, что вы должны держать свои API,
    малого и конкретно определены на ранних стадиях. Требования изменяются с течением времени, но
    а не с фронтальной загрузкой допущений в API для ваших модулей, нагрузки
    их на один уровень абстракции: модуль поставил перед собой. Если требования
    * не делаем * изменение и "сделай один бетон-вещь" больше не имеет смысла, то просто
    написать новый модуль, который делает, что вам нужно. «Сделай одну конкретную вещь-'
    остается действительным и ценным модуль для НПМ экосистемы, и ваш курс
    коррекция не будет стоить вам ничего, кроме простой замены одного модуля для
    другой.

11. И, наконец, помните, что ваше хранилище управления версиями и ее
    встроенный README переживет свой [репозиторий хост] (https://github.com) и
    любой из вещей, которые вы гиперссылкой на - особенно изображений - так * * рядный ничего
    что имеет важное значение для будущих пользователей grokking свою работу.


## Бонус: простое README

Не секрет, что это также формат, используемый в
[** common-readme **] (https://github.com/noffle/common-readme), набор правил для написания README
и генератор, работающий в командной строке. Если вам нравится то, что здесь написано,
вы можете сэкономить время на написание своих README-шек с помощью `common-readme`. Здесь же можно найти примеры
реальных ридми, написанных в этом формате.


## Всем ридми!

Теперь идите и напишите ридми на все ваши модули,
сделайте вашу работу понятной и доступной с помощью отлично написанной документации!


## Об авторе

Я -  [noffle] (http://blog.eight45.net/about/). [Мой блог] (http://blog.eight45.net),
[мой твиттер] (https://twitter.com/noffle), и [мой код] (https://github.com/noffle).

Этот маленький проект был начат еще в мае в Берлине на конференции squatconf, где я разбирался,
как "старички" Perl-а пишут свою документацию, а также сокрушался из-за состояния
моих собственных README в Node. Это побудило меня создать
[common-readme] (https://github.com/noffle/common-readme). Раздел "Советы по README"
был переполнен и я решил, что будет полезно собрать их всех в статью о том, как писать ридми.
Так появилось "Искусство README".


## Сноски

1. <a name="footnote-1"> </a> Спасибо,
   [Sixes666] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8akpz6)!

1. <a name="footnote-2"> </a> Смотрите [The Jargon File] (http://catb.org/~esr/jargon/html/R/README-file.html).
   Тем не менее, большинство систем сегодня не будет сортировать столичными нижнем регистре
   символов, снижая полезность этой конвенции, чтобы только визуальный
   плакатное всех заглавных букв.


## Благодарности

Выражаю благодарность [@mafintosh] (https://github.com/mafintosh) и
[@feross] (Https://github.com/feross), которые подтолкнули меня написать эту статью
и сдвинули дело с мертвой точки.

Спасибо следующим удивительным читателям за то, что помогали исправлять ошибки
и посылать мне PR-ы :heart: :

- [@ungoldman] (Https://github.com/ungoldman)
- [@boidolr] (Https://github.com/boidolr)
- [@imjoehaines] (Https://github.com/imjoehaines)
- [@radarhere] (Https://github.com/radarhere)
- [@joshmanders] (Https://github.com/joshmanders)
- [@ddbeck] (Https://github.com/ddbeck)
- [@StevenMaude] (Https://github.com/StevenMaude)

И спасибо моим читателям за их отзывы:

- [entiat_blues] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8am9w5)


## Перевод
Команда энтузиастов-переводчиков, рискнувших перевести эту статью:
- [@sapunovnik] (https://github.com/Sapunov)
- [@cheburashka21] (https://github.com/IvanGamazov)
- [@skyrocker] (https://github.com/chulanovskyi)
- [@foromik] (https://github.com/FoRomik)
- [@wladyslaw] (https://github.com/vlshat)

## Pull request-ы приветствуются!

Нашли ошибку? Что-то непонятно? Пришлите мне
[pull-request] (https://github.com/Sapunov/art-of-readme/pulls)!


<<<<<<< HEAD
## Pull requests приветствуются!

Нашли ошибку? Где-то бессмыслица? Пришлите мне [pull request] (https://github.com/noffle/art-of-readme/pulls)!
