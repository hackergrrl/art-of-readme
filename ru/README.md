# Искусство README

## [1] Происхождение

Как, когда и где появился термин "README"?

Первое упоминание относится к, как минимум, 1970-м годам [и
PDP-10] (http://pdp-10.trailing-edge.com/decuslib10-04/01/43,50322/read.me.html),
хотя на самом деле, скорее отсылает нас в дни информативных бумажных заметок, возвышающихся
над стеком перфокарт, с нацарапанным "READ ME!" на них, описывавших использование этих перфокарт.

Читатель может предполодить<sup>[1](#footnote-1)</sup>, что название README может быть отсылкой к "Приключениям Алисы
в Стране Чудес" Льюиса Кэрола, где были бутылочка и пирог, с надписями "Выпей меня" и "Съешь меня" соответственно.

Надпись README, состоящая из всех заглавных букв является лишь одной из особенностей.
В дополнение к заметности самой фразы, написанной всеми заглавными буквами,
у такой надписи есть еще одна примечательная черта - UNIX-системы помещают слова, начинающиеся с заглавных букв,
наверх списка при сортировке. Таким образом, файл с названием README
(состоящим из всех заглавных букв), окажется в начале списка <sup>[2](#footnote-2)</sup>.

Посыл прост и понятен - это важная информация, с которой необходимо ознакомиться прежде,
чем продолжить работу. Давайте разберемся, что представляет собой "важная информация "в наш век информационных технологий.


## [2] Для создателей, для потребителей

Это статья о файлах README. О том, что они делают, почему они так необходимы,
и как правильно их готовить.

Это написано для создателей различных модулей, ибо, как создатель модулей, ваша работа состоит в том, чтобы
создать что-то, что будет существовать долго и счастливо. Это должно быть вашей мотивацией, даже если вы, как автор,
не имеете никакого желания делиться своей работой. Пройдет полгода, и написанный вами модуль покажется вам совершенно
непонятным и незнакомым, просто потому, что человеку свойственно забывать неиспользуемую информацию.

Это важно и для тех, кто пользуется модулем. В конечном счете,
каждый автор чего-либо является и пользователем. Никто из нас не может
похвастаться абсолютной независимостью - мы все используем
в нашей работе что-то, уже созданное до нас.

Все вышесказанное верно для абсолютно всех языков программирования.


## [3] Модули бывают разные: плохие и хорошие

Экосистема nodejs подпитывается своими модулями. [npm] (https://npmjs.org) - это
магия, которая заставляет все это работать. В течение недели, разработчики оценивают
десятки модулей для включения их в свои проекты. Все вместе - очень мощный инструмент,
который может быть развернут и использован так же быстро, как вы напишете в консоли `npm install`.

Как и у любой экосистемы, которая является общедоступной, качество модулей может сильно варьироваться.
npm делает все возможное, чтобы все эти модули были доступны каждому. Тем не менее, эти инструменты
сильно разнятся: некоторые из них новые и отлично работают, другие не работают, а третьи
находятся где-то посередине. Есть и такие, о которых мы вообще не знаем, зачем они нужны.

Для модулей, это может принимать форму неточных или бесполезных
имен (кто нибудь может сказать, что делает модуль `fudge`?), отсутствия  документации,
тестов, отсутствие комментариев в исходном коде или непонятные имена функций.

Многие из них не имеют активного сопровождающего. Если модуль нет человека, способного
ответить на вопросы и объяснить, что делает модуль, в сочетании с отсутствием какой-либо
документация, модуль превращается в странный инопланетный артефакт, непригодный для использования и непонятный вообще никому.

А что касается тех модулей, у которых есть какая-нибудь документация? Может быть,
это просто описание в одну строку: `" числа сортируются по их шестнадцатиричному коду "`. Может быть, это фрагмент кода примера.
Это уже лучше чем ничего, но тоже приводит к худшему сценарию - копание в исходном коде,
с единственной целью - понять, как же все-таки оно работает.
Написание превосходной документации позволит не подпускать будущих пользователей к исходным
кодам, позволит им в полной мере насладиться удобством использования вашего модуля. А как оно устроено внутри -
им, пользователям, уже не важно.

Вся экосистема состоит из нескончаемого списка простых модулей, делающих одну единственную вещь, и никакую другую.
Есть [исключения] (https://github.com/lodash/lodash), но они покрывают очень малую часть экосистемы.

Из этого следует простой вывод - найти действительно хороший модуль, который делает то,
что тебе нужно, может быть действительно сложной задачей.

И это нормально. Гораздо лучше иметь не очень высокую входную планку и понимание происходящего,
чем иметь очень маленькое сообщество, в жизни которого могут принимать участие единицы.

Плюс ко всему, чем непонятнее что-либо - тем важнее обратиться за помощью.


## [4] Все дороги ведут к README.txt

Сообщество Nodejs ответило на вызов понятности различными способами.

Некоторые опытные разработчики на Nodejs объединились, чтобы создать [рекомендованные  списки]
(https://github.com/sindresorhus/awesome-nodejs) качественных модулей.

Разработчики использовали их несколько лет, проверили сотни и тысячи модулей,
чтобы поделиться с новичками самыми сливками: в каждой категории только лучшие модули.
Это приняло форму RSS-ленты и e-mail рассылки со списками новых модулей, признаных
полезными различными опытными членами сообщества.

Как насчет социального графа? Эта идея привела к созданию
[Node-modules.com] (http://node-modules.com/), замене npm-поиска, которая
использует ваш социальный граф  на Github  чтобы найти модули, которые нравятся
вашим друзьям или были ими сделаны.

Конечно же есть и [поиск] (https://npmjs.org), встроенный в npm:
безопасный и являющийся точкой входа для всех новых разработчиков.

Независимо от того какой подход вам больше нравится,
и не смотря на то где ищущий модули в конечном счете
находит себя: на [npmjs.org] (https://npmjs.org) или
[Github.com] (https://github.com) или где-то еще,
абсолютно все будут читать ваш README. И раз уж до README все равно добрались,
то как сделать его максимально полезным для конечного пользователя?


## Профессиональный искатель модулей


### [5] README: Ваш универсальный магазин

README - это первое, на что смотрит пользователь модуля - а, возможно, и последнее.
Потребитель хочет, чтобы модуль удовлетворил его потребности, так что вы должны доходчиво объяснить,
какие потребности закрывает ваш модуль и насколько эффективно он это делает.

Ваша задача заключается в:

1. рассказе о том, что есть из себя представляет ваш модуль(с контекстом)
2. показе того, как он работает
3. показе, как пользователи могут использовать его
4. рассказе о любых других сопутствующих деталях

Это * ваша * работа. Именно создатель модуля должен доказать, что его детище является
блестящим драгоценным камнем в море неподобающих модулей. Так как очень многие разработчики прежде всего будут
искать путь к вашему README, качество здесь - это оценка вашей работы перед лицом общественности.


### [6] Краткость

Отсутствие README является мощнейшим красным флагом, но даже длинное README не
говорит о высоком качестве работы. Идеальный README должен быть настолько коротким, насколько
коротким он только может быть. Подробная документация хороша - сделайте отдельные
страницы для этого! - но сохраните ваш README лаконичным.


### [7] Учитесь прошлым

Говорят, что те, кто не оглядывается назад, обречены повторять свои ошибки
снова и снова. Разработчики пишут документацию в течение некоторого количества
лет. Было бы расточительством не оглянуться немного назад и посмотреть, что люди
делали незадолго до Node.

Perl, со всей критикой, которая на него обрушивается, в некотором смысле является духовным прародителем
nodejs. Оба являются скриптовыми языками высокого уровня, принявшими многие идиомы UNIX, плотно
используются в интернете, и оба имеют широкую экосистему модулей.

Так получается, что [монахи] (http://perlmonks.org) сообщества Perl
имеют большой опыт в написании
[качественных README] (http://search.cpan.org/~kane/Archive-Tar/lib/Archive/Tar.pm).
CPAN - замечательный ресурс, который стоит прочитать, чтобы узнать больше о сообществе,
которое неуклонно пишет высококачественную документацию.


-----
###### ДАЛЬНЕЙШИЙ ТЕКСТ - ПЕРЕВОД ГУГЛА, НИКАК НЕ РЕДАКТИРОВАЛСЯ!!!!
-----


### [8] Нет README? Нет абстракции

Отсутствие README означает что разработчикам нужно будет вникать в код для того, чтобы
понять его.

У [монахов из Perl] (https://en.wikipedia.org/wiki/PerlMonks) есть мудрость касательно этого вопроса:

> Ваша документация будет полноценной, когда кто угодно сможет использовать ваш модуль без
> необходимости даже открывать его код. Это очень важно. Это даёт вам возможность отделить
> документированный интерфейс вашего модуля от его внутренней реализации. Это хорошо, 
> так как это означает, что вы можете свободно изменять "внутренности" модуля 
> в то время как интерфейс остается неизменным.
>
> Помните: документация, а не код, определяет то, что делает модуль.
- [Кен Уильямс] (http://mathforum.org/ken/perl_modules.html#document)


### [9] Ключевые элементы

После того, как обнаружится README, необходимо будет проанализировать его и определить,
соответствует ли модуль потребностям разработки. По сути, для мозга, это превращается в 
серию поисков по паттерну, где каждый шаг погружает всё глубже внутрь модуля и его детали.

Скажем, к примеру, мой поиск модуля обнаружения 2D столкновений  приводит меня
к [`collide-2d-aabb-aabb`] (https://github.com/noffle/collide-2d-aabb-aabb).
Я начинаю рассматривать его сверху вниз:

1. *Имя* -- самоочевидные названия являются лучшими. `Collide-2d-aabb-aabb` звучит многообещающе,
   хотя это предполагает, что я знаю, что такое "aabb". Если имя звучит слишком
   расплывчато или несвязно, это может стать сигналом, чтобы двигаться дальше.

2. *В-одну-строку* -- наличие описания модуля "в-одну-строку" очень полезено для
   получения представления о том, что модуль делает в слегка подробных деталях.
   В `Collide-2d-aabb-aabb` говорится следующее

   > Определяет столкновение движущегося [параллельного осям ограничивающего прямоугольника] 
   >(https://ru.wikipedia.org/wiki/AABB) (AABB) с другим AABB.

   Здорово: он определяет, что такое AABB, и то, что модуль делает. Идём дальше, чтобы оценить,
   насколько хорошо это впишется в мой код.

3. *Использование* -- прежде чем нырять с головой в API, было бы здорово увидеть модуль в действии. 
   Я могу быстро определить по JS примерам подходит ли это к желаемому стилю и проблеме.
   У людей есть много мнений на такие вещи, как обещания, обратные вызовы и ES6.
   Если это отвечает всем требованиям, то я могу перейти к более подробным деталям.

4. *API* -- название, описание и использование этого модуля заинтриговали меня.
   Я с большой вероятностью буду использовать этот модуль на этой стадии. Мне просто нужно просмотреть
   API для уверенности, что модуль делает именно то, что мне нужно, и что он легко сможет
   интегрироваться в мой код. Раздел API должен подробно рассказать про объекты и функции модуля,
   их подписи, типы возвращаемых значений, их вызовы и события. Типы должны быть указаны, если они не очевидны.
   Предостережения должны быть чётко разъяснены.

5. *Установка* -- если я дочитал до этого раздела, значит я решился опробовать этот модуль.
   Если есть нестандартные указания по установке, здесь им самое место. Но даже если это обычный `npm install`
   я хотел бы знать и об этом. Начинающие пользователи постоянно начинают использовать Node,
   так что наличие ссылки на [npmjs](https://www.npmjs.com/) и примеры команд установки помогает таким
   пользователям разобраться как работают модули Node.

6. *Лицензия* -- большинство модулей размещают этот раздел в самом низу, но, наверное, лучше
   переместить его в самый верх. Вы, скорее всего, исключите модуль ОЧЕНЬ быстро, если он имеет
   несовместимую лицензию с вашей работой. Я вообще придерживаюсь букета из MIT / BSD / X11 / ISC. 
   Если у вас есть не рекомендованная лицензия, прикрепите её в самый верх модуля, чтобы предотвратить путаницу.


## [10] Когнитивная утекают

Упорядочение выше, не был выбран случайным образом.

потребители модулей используют множество модулей, и нужно смотреть на многих модулей.

После того, как вы посмотрели на сотни модулей вы начинаете замечать, что ум
выгоды от предсказуемый характер.

Вы также начать строить свой собственный личный эвристики для какую информацию вы
хотите, и какие красные флаги дисквалифицировать модули быстро.

Таким образом, отсюда следует, что в README желательно иметь:

1. предсказуемый формат
2. некоторые ключевые элементы присутствуют

Вам не нужно использовать * этот формат *, но стараюсь быть последовательным, чтобы сохранить пользователей
драгоценные познавательные циклы.

Упорядочение представленная здесь любовно называют "когнитивным утекают",
и можно представить себе в виде воронки в вертикальном положении, где самый широкий конец содержит
Широчайшие более важные детали, и перемещение глубже в воронку подарки
более конкретные детали, которые уместны только для читателя, который интересуется
достаточно в своей работе, что глубоко, что достигнуто в документе. И, наконец,
дно может быть зарезервирован для деталей, которые только те, заинтригованы тем глубже
контекст работы (фон, кредиты, Библио, ...)

Опять же, монахи Perl есть мудрость, чтобы делиться на эту тему:

> Уровень детализации в документации модуля Perl как правило, идет от
> Менее подробные, чтобы более детально. Ваш СИНТАКСИС раздел должен
> Содержит минимальный пример использования (возможно, всего лишь одной линии
> Код; пропустить необычные случаи использования или что-нибудь не нужны большинством
> пользователей); Описание должно описать свой модуль в широком смысле,
> Как правило, в несколько пунктов; более подробно модуля
> процедуры или методы, длинные примеры кода, или другие в глубины
> Материал должен быть приведен в последующих разделах.
>
> В идеале, кто-то, кто немного знаком с модулем должен быть
> Возможность освежить в памяти без нажатия на клавишу "страницу вниз". Как ваш
> Читатель продолжает через документ, они должны получать
> Прогрессивно большее количество знаний. - От `perlmodstyle`


## [11] Забота о времени людей

Потрясающие; упорядочение этих ключевых элементов должны определяться, как быстро
они позволяют кому-то «короткое замыкание» и под залог Вашего модуля.

Это звучит мрачно, не так ли? Но думать об этом: ваша работа, когда вы делаете
она с оптимальным альтруизма в виду, не "продать" людей на работе. Это в
пусть оценить то, что ваше творение делает настолько объективно, насколько это возможно, и решить,
отвечает ли она их потребности или нет. Не, скажем, увеличить ваши загрузки или
UserBase.

Такое мышление не обращается к каждому; она требует проверки вашего эго на
дверь и позволить работу говорить за себя как можно больше. Ваша единственная работа
чтобы описать свое обещание, как сжато, как вы можете, так что модуль спелеологи может
либо использовать вашу работу, когда это нужным, или двигаться дальше к чему-то другому, что делает.


## [12] Бонус: другие хорошие практики

Вне ключевых моментов статьи, существуют и другие методы вы можете
следовать (или не следовать), чтобы поднять планку качества вашего README еще дальше, и
максимизировать свою полезность для других.

1. рассмотреть вопрос о включении ** ** Фон раздел, если ваш модуль зависит от того,
   важно, но не так широко известных абстракциями или других экосистем. Функция
   из [ `рассекает-between`] (https://github.com/noffle/bisecting-between) не
   сразу видно из его названия, поэтому она подробный * Фон * раздел
   определить и ссылку на больших понятий и абстракций нужно
   понимать и использовать его обращал внимания. Это также отличное место, чтобы объяснить
   мотивация модуля, если аналогичные модули уже существуют на НПМ.

2. Агрессивно linkify! Если говорить о других модулях, идей или людей, сделать
   что текст ссылки ссылку, так что посетители могут более легко обращал внимания на свой модуль
   и идеи он опирается. Немногие модули существуют в вакууме: вся работа идет
   от другой работы, поэтому он платит, чтобы помочь пользователям следовать за историю вашего модуля и
   вдохновение.

3. Включить информацию о типах аргументов и возвращаемых параметров, если это не
   очевидно. Предпочитают конвенции, где это возможно ( `cb`, вероятно, означает обратный вызов
   функция, `num`, вероятно, означает` Number`).

4. Включите пример кода в ** Использование ** в виде файла в вашем репо - может быть, как
   `Example.js`. Это здорово иметь README код, который пользователи могут реально работать, если
   они клонировать репозиторий.

5. Будьте рассудительным в вашем использовании значков. Они легко
   [Злоупотребление] (https://github.com/angular/angular). Они также могут быть питательной
   Основанием для bikeshedding и бесконечных споров. Они добавляют визуальный шум к вашему
   README, и как правило, только функция, если пользователь читает ваш уценки в
   браузер в Интернете, так как образы, как правило, размещается в другом месте на
   Интернет. Для каждого знака, рассмотреть следующие вопросы: "что реальное значение этот значок обеспечивая
   к типичным зрителем этого README "? Есть CI значок, чтобы показать сборки / тест
   положение дел? этот сигнал будет лучше добраться до важных партий по электронной почте
   Сопровождающие или автоматически создавая проблему - всегда считают
   аудитория данных в вашем README и спросите себя, если есть поток для
   что данные, которые могут лучше достичь своей целевой аудитории.

6. API форматирования является весьма bikesheddable. Используйте любой формат, который вы считаете наиболее
   ясно, но убедитесь, что ваш формат выражает важные тонкости:

   а. какие параметры не являются обязательными, и их значения по умолчанию

   б. говоря информацию о типе, где это не очевидно из конвенции

   гр. для `opts` параметров объекта, подробно описать все ключи и значения, которые принимаются

   d. не уклоняться от предоставления крошечный пример использования API функцию, если
      их использование не является очевидным или полностью покрыты в ** Использование ** раздела.
      Тем не менее, это также может быть сильным сигналом, что функция слишком сложна
      и должен быть переработан, разбиты на более мелкие функции, или удалены
      в целом

   е. агрессивно linkify специализированную терминологию! В уценки вы можете сохранить
      [Сноски] (https://daringfireball.net/projects/markdown/syntax#link) в
      в нижней части документа, поэтому обращаясь к ним несколько раз в течение
      становится дешевым. Некоторые из моих личных предпочтений по апи форматирования может быть
      найденный
      [Здесь] (https://github.com/noffle/common-readme/blob/master/api_formatting.md)

7. Если ваш модуль представляет собой небольшой набор функций без гражданства, имеющие
   ** Использование ** раздел как [Node РЕПЛ
   сессия] (https://github.com/noffle/bisecting-between#example) функции
   вызовы и результаты могут общаться использование более ясно, чем исходный код
   файл для запуска.

8. Если ваш модуль обеспечивает CLI (интерфейс командной строки) вместо (или в
    дополнение) программный API, показывают примеры использования в качестве командных вызовов
    и их вывод. если вы создаете или изменить файл, `cat` его, чтобы продемонстрировать
    изменение до и после.

9. Не забывайте использовать `package.json`
    [Ключевые слова] (https://docs.npmjs.com/files/package.json#keywords) направить
    модуль спелеологи к вашему порогу.

10. Чем больше вы изменить свой API, тем больше работы вам необходимо приложить обновления
    документация - Смысл заключается в том, что вы должны держать свои API,
    малого и конкретно определены на ранних стадиях. Требования изменяются с течением времени, но
    а не с фронтальной загрузкой допущений в API для ваших модулей, нагрузки
    их на один уровень абстракции: модуль поставил перед собой. Если требования
    * не делаем * изменение и "сделай один бетон-вещь" больше не имеет смысла, то просто
    написать новый модуль, который делает, что вам нужно. «Сделай одну конкретную вещь-'
    остается действительным и ценным модуль для НПМ экосистемы, и ваш курс
    коррекция не будет стоить вам ничего, кроме простой замены одного модуля для
    другой.

11. И, наконец, помните, что ваше хранилище управления версиями и ее
    встроенный README переживет свой [репозиторий хост] (https://github.com) и
    любой из вещей, которые вы гиперссылкой на - особенно изображений - так * * рядный ничего
    что имеет важное значение для будущих пользователей grokking свою работу.


## [13] Бонус: простое README

Не случайно, это также формат, используемый
[** Общего ридми **] (https://github.com/noffle/common-readme), набор README
руководящих принципов и генератор командной строки под рукой. Если вам нравится то, что здесь написано,
Вы можете сэкономить время на написание READMEs с `здравым readme`. Ты найдешь
реальные примеры модулей с этим форматом, тоже.


## [14] Призыв к оружию!

Идите вперед, храбрый модуль спелеолог, и сделать вашу работу обнаруживаемым и полезной
через отличную документацию!


## [15] Автор

Я [noffle] (http://blog.eight45.net/about/). Я, как известно,
[Блог] (http://blog.eight45.net), [чирикать] (https://twitter.com/noffle), и
[Хак] (https://github.com/noffle).

Этот маленький проект был начат еще в мае в Берлине в squatconf, где я был
копаться в том, как Perl монахи написали свою документацию, а также посетовал
состояние моих файлы README в узле экосистемы. Это побудило меня создать
[Общего ридми] (https://github.com/noffle/common-readme). "Ридми советы"
раздел разливалась с советами, хотя, который я решил было бы полезно собраны
в статье о написании READMEs. Таким образом, искусство README родился!


## [16] Сноски

1. <a name="footnote-1"> </a> Спасибо,
   [Sixes666] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8akpz6)!

1. <a name="footnote-2"> </a> Смотрите [The Jargon File] (http://catb.org/~esr/jargon/html/R/README-file.html).
   Тем не менее, большинство систем сегодня не будет сортировать столичными нижнем регистре
   символов, снижая полезность этой конвенции, чтобы только визуальный
   плакатное всех заглавных букв.


## [17] Благодарности

Искреннее спасибо [@mafintosh] (https://github.com/mafintosh) и
[@feross] (Https://github.com/feross) для поощрения мне нужно, чтобы получить эту
Идея с мертвой точки и начать писать!

Спасибо следующим удивительным читателям замечать ошибки и посылать мне
Реципиенты: сердце::

- [@ungoldman] (Https://github.com/ungoldman)
- [@boidolr] (Https://github.com/boidolr)
- [@imjoehaines] (Https://github.com/imjoehaines)
- [@radarhere] (Https://github.com/radarhere)
- [@joshmanders] (Https://github.com/joshmanders)
- [@ddbeck] (Https://github.com/ddbeck)
- [@StevenMaude] (Https://github.com/StevenMaude)

И спасибо моим читателям за их общей обратной связи:

- [Entiat_blues] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8am9w5)


## [18] Pull requests приветствуются!

Нашли ошибку? Где-то бессмыслица? Пришлите мне [pull request] (https://github.com/noffle/art-of-readme/pulls)!
