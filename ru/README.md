# Искусство README

## [1] Происхождение

Как, когда и где появился термин "README"?

Первое упоминание относится к, как минимум, 1970-м годам [и
PDP-10] (http://pdp-10.trailing-edge.com/decuslib10-04/01/43,50322/read.me.html),
хотя на самом деле, скорее отсылает нас в дни информативных бумажных заметок, возвышающихся
над стеком перфокарт, с нацарапанным "READ ME!" на них, описывавших использование этих перфокарт.

Читатель может предполодить<sup>[1](#footnote-1)</sup>, что название README может быть отсылкой к "Приключениям Алисы
в Стране Чудес" Льюиса Кэрола, где были бутылочка и пирог, с надписями "Выпей меня" и "Съешь меня" соответственно.

Надпись README, состоящая из всех заглавных букв является лишь одной из особенностей.
В дополнение к заметности самой фразы, написанной всеми заглавными буквами,
у такой надписи есть еще одна примечательная черта - UNIX-системы помещают слова, начинающиеся с заглавных букв,
наверх списка при сортировке. Таким образом, файл с названием README
(состоящим из всех заглавных букв), окажется в начале списка <sup>[2](#footnote-2)</sup>.

Посыл прост и понятен - это важная информация, с которой необходимо ознакомиться прежде,
чем продолжить работу. Давайте разберемся, что представляет собой "важная информация "в наш век информационных технологий.


## [2] Для создателей, для потребителей

Это статья о файлах README. О том, что они делают, почему они так необходимы,
и как правильно их готовить.

Это написано для создателей различных модулей, ибо, как создатель модулей, ваша работа состоит в том, чтобы
создать что-то, что будет существовать долго и счастливо. Это должно быть вашей мотивацией, даже если вы, как автор,
не имеете никакого желания делиться своей работой. Пройдет полгода, и написанный вами модуль покажется вам совершенно
непонятным и незнакомым, просто потому, что человеку свойственно забывать неиспользуемую информацию.

Это важно и для тех, кто пользуется модулем. В конечном счете,
каждый автор чего-либо является и пользователем. Никто из нас не может
похвастаться абсолютной независимостью - мы все используем
в нашей работе что-то, уже созданное до нас.

Все вышесказанное верно для абсолютно всех языков программирования.


## [3] Модули бывают разные: плохие и хорошие

Экосистема nodejs подпитывается своими модулями. [npm] (https://npmjs.org) - это
магия, которая заставляет все это работать. В течение недели, разработчики оценивают
десятки модулей для включения их в свои проекты. Все вместе - очень мощный инструмент,
который может быть развернут и использован так же быстро, как вы напишете в консоли `npm install`.

Как и у любой экосистемы, которая является общедоступной, качество модулей может сильно варьироваться.
npm делает все возможное, чтобы все эти модули были доступны каждому. Тем не менее, эти инструменты
сильно разнятся: некоторые из них новые и отлично работают, другие не работают, а третьи
находятся где-то посередине. Есть и такие, о которых мы вообще не знаем, зачем они нужны.

Для модулей, это может принимать форму неточных или бесполезных
имен (кто нибудь может сказать, что делает модуль `fudge`?), отсутствия  документации,
тестов, отсутствие комментариев в исходном коде или непонятные имена функций.

Многие из них не имеют активного сопровождающего. Если модуль нет человека, способного
ответить на вопросы и объяснить, что делает модуль, в сочетании с отсутствием какой-либо
документация, модуль превращается в странный инопланетный артефакт, непригодный для использования и непонятный вообще никому.

А что касается тех модулей, у которых есть какая-нибудь документация? Может быть,
это просто описание в одну строку: `" числа сортируются по их шестнадцатиричному коду "`. Может быть, это фрагмент кода примера.
Это уже лучше чем ничего, но тоже приводит к худшему сценарию - копание в исходном коде,
с единственной целью - понять, как же все-таки оно работает.
Написание превосходной документации позволит не подпускать будущих пользователей к исходным
кодам, позволит им в полной мере насладиться удобством использования вашего модуля. А как оно устроено внутри -
им, пользователям, уже не важно.

Вся экосистема состоит из нескончаемого списка простых модулей, делающих одну единственную вещь, и никакую другую.
Есть [исключения] (https://github.com/lodash/lodash), но они покрывают очень малую часть экосистемы.

Из этого следует простой вывод - найти действительно хороший модуль, который делает то,
что тебе нужно, может быть действительно сложной задачей.

И это нормально. Гораздо лучше иметь не очень высокую входную планку и понимание происходящего,
чем иметь очень маленькое сообщество, в жизни которого могут принимать участие единицы.

Плюс ко всему, чем непонятнее что-либо - тем важнее обратиться за помощью.


## [4] Все дороги ведут к README.txt

Сообщество Nodejs ответило на вызов понятности различными способами.

Некоторые опытные разработчики на Nodejs объединились, чтобы создать [рекомендованные  списки]
(https://github.com/sindresorhus/awesome-nodejs) качественных модулей.

Разработчики использовали их несколько лет, проверили сотни и тысячи модулей,
чтобы поделиться с новичками самыми сливками: в каждой категории только лучшие модули.
Это приняло форму RSS-ленты и e-mail рассылки со списками новых модулей, признаных
полезными различными опытными членами сообщества.

Как насчет социального графа? Эта идея привела к созданию
[Node-modules.com] (http://node-modules.com/), замене npm-поиска, которая
использует ваш социальный граф  на Github  чтобы найти модули, которые нравятся
вашим друзьям или были ими сделаны.

Конечно же есть и [поиск] (https://npmjs.org), встроенный в npm:
безопасный и являющийся точкой входа для всех новых разработчиков.

Независимо от того какой подход вам больше нравится,
и не смотря на то где ищущий модули в конечном счете
находит себя: на [npmjs.org] (https://npmjs.org) или
[Github.com] (https://github.com) или где-то еще,
абсолютно все будут читать ваш README. И раз уж до README все равно добрались,
то как сделать его максимально полезным для конечного пользователя?


## Профессиональный искатель модулей


### [5] README: Ваш универсальный магазин

README - это первое, на что смотрит пользователь модуля - а, возможно, и последнее.
Потребитель хочет, чтобы модуль удовлетворил его потребности, так что вы должны доходчиво объяснить,
какие потребности закрывает ваш модуль и насколько эффективно он это делает.

Ваша задача заключается в:

1. рассказе о том, что есть из себя представляет ваш модуль(с контекстом)
2. показе того, как он работает
3. показе, как пользователи могут использовать его
4. рассказе о любых других сопутствующих деталях

Это * ваша * работа. Именно создатель модуля должен доказать, что его детище является
блестящим драгоценным камнем в море неподобающих модулей. Так как очень многие разработчики прежде всего будут
искать путь к вашему README, качество здесь - это оценка вашей работы перед лицом общественности.


### [6] Краткость

Отсутствие README является мощнейшим красным флагом, но даже длинное README не
говорит о высоком качестве работы. Идеальный README должен быть настолько коротким, насколько
коротким он только может быть. Подробная документация хороша - сделайте отдельные
страницы для этого! - но сохраните ваш README лаконичным.


### [7] Учитесь прошлым

Говорят, что те, кто не оглядывается назад, обречены повторять свои ошибки
снова и снова. Разработчики пишут документацию в течение некоторого количества
лет. Было бы расточительством не оглянуться немного назад и посмотреть, что люди
делали незадолго до Node.

Perl, со всей критикой, которая на него обрушивается, в некотором смысле является духовным прародителем
nodejs. Оба являются скриптовыми языками высокого уровня, принявшими многие идиомы UNIX, плотно
используются в интернете, и оба имеют широкую экосистему модулей.

Так получается, что [монахи] (http://perlmonks.org) сообщества Perl
имеют большой опыт в написании
[качественных README] (http://search.cpan.org/~kane/Archive-Tar/lib/Archive/Tar.pm).
CPAN - замечательный ресурс, который стоит прочитать, чтобы узнать больше о сообществе,
которое неуклонно пишет высококачественную документацию.


-----
###### ДАЛЬНЕЙШИЙ ТЕКСТ - ПЕРЕВОД ГУГЛА, НИКАК НЕ РЕДАКТИРОВАЛСЯ!!!!
-----


### [8] Нет README? Нет абстракции

Ни один README не означает, что разработчикам нужно будет вникать в код для того, чтобы
понимать это.

Монахи Perl есть мудрость, чтобы поделиться по этому вопросу:

> Ваша документация будет завершена, когда кто-то может использовать модуль без когда-либо
> Того, чтобы посмотреть на его код. Это очень важно. Это делает возможным для
> Отделить документированный интерфейс вашего модуля от его внутренней
> Реализации (кишок). Это хорошо, потому что это означает, что вы свободны
> Изменить внутренности модуля, до тех пор пока интерфейс остается неизменным.
>
> Помните: документация, а не код, определяет то, что делает модуль.
- [Кен Уильямс] (http://mathforum.org/ken/perl_modules.html#document)


### [9] Ключевые элементы

После того, как README расположен, храбрый модуль спелеолог должен проверить его распознать, если
он соответствует потребностям разработчика. Это становится по существу ряд узора
сопоставив проблемы для их мозга, чтобы решить, где каждый шаг берет их глубже
в модуль и его детали.

Скажем, к примеру, мой поиск модуля обнаружения столкновений 2D приводит меня
к [ `соударяются-2d-Аабб-aabb`] (https://github.com/noffle/collide-2d-aabb-aabb). я
начинают рассматривать его сверху вниз:

1. * Имя * - самоочевидные названия являются лучшими. `Collide-2d-AABB-aabb` звуки
   многообещающим, хотя он предполагает, я знаю, что такое "AABB" есть. Если имя звучит слишком
   расплывчаты или не связаны, это может быть сигналом, чтобы двигаться дальше.

2. * One-вкладыш * - имеющий один вкладыш, который описывает модуль полезен для
   получить представление о том, что модуль делает в немного более подробно.
   `Сталкиваются-2d-AABB-aabb` говорит, что это

   > Определяет, сталкивается ли перемещение по оси выровнен ограничивающего прямоугольника (AABB) с
   > другие AABBs.

   Высокий: он определяет, что такое ААББ есть, и то, что модуль делает. Теперь, чтобы оценить, насколько
   хорошо было бы вписаться в мой код:

3. * Использование * - а не начинать вникать в API Docs, было бы здорово
   увидеть, что модуль выглядит в действии. Я могу быстро определить, является ли
   Пример JS подходит желаемый стиль и проблемы. У людей есть много мнений
   на такие вещи, как обещания / обратных вызовов и ES6. Если это не соответствует законопроект, то я
   может перейти к более подробно.

4. * API * - название, описание и использование этого модуля все звуковой привлекательной
   мне. Я очень вероятно, использовать этот модуль в этой точке. Мне просто нужно сканировать
   API-интерфейс, чтобы убедиться, что он делает именно то, что мне нужно, и что она будет интегрировать
   легко в мой код. Раздел API должен подробно объекты модуля
   и функции, их подписи, типы возвращаемых значений, обратные вызовы и события в хорошем
   подробно. Типы должны быть включены, если они не очевидны. Предостережения должны быть
   ясно.

5. * Установка * - если я прочитал это далеко вниз, то я продал на опробовать
   модуль. Если есть нестандартные указания по монтажу, вот где они идут,
   но даже если это просто обычный `НПМ install` Я хотел бы иметь, что перечисленные
   слишком. Новые пользователи начинают использовать Сев.Узел все время, так что наличие ссылки на npmjs.org
   и команды установки помогает то, что пользователь с ресурсами, чтобы выяснить, как Node
   модули работают.

6. * Лицензия * - большинство модулей положить это в самом низу, но это может
   на самом деле лучше иметь выше; вы, вероятно, чтобы исключить модуль ОЧЕНЬ
   быстро, если это имеет несовместимую лицензию на вашу работу. Я вообще придерживаться
   ароматы MIT / BSD / X11 / ISC. Если у вас есть непермиссивной лицензию, придерживаться его
   на самом верху модуля, чтобы предотвратить путаницу


## [10] Когнитивная вороyка

Порядок, в котором написано все вышеперечисленное, не был выбран случайным образом.

Пользователи используют множество модулей, поэтому необходимо на них взглянуть.

После того, как вы просмотрите сотни модулей, вы заметите, что мозг легче воспринимает предсказуемые шаблоны.

Вы также начнете опираться на собственные предположения о том, какая информация вам нужна, и какие признаки быстро "дисквалифицируют" модуль. //на мой взгляд, не свосем корректно. Как можно лучше?

Таким образом, отсюда следует, что в README желательно иметь:

1. предсказуемый формат
2. представление определенных ключевых элементов

Вам не обязаны использовать * именно этот формат *, но постарайтесь быть последовательным, чтобы сохранить внимание пользователей.

Указание, представленное здесь, нежно называют "когнитивная воронка" и может быть представлено как как
вертикальная воронка на широком конце которой наиболее обширные детали, а при движении вглубь воронки мы встречаем более специфичные детали, которые интересны только для читателя, который настолько заинтересован в вашей работе, что был вынужден достигнуть такой глубины в документе. Наконец, дно может быть отведено под детали для интересующихся глубочайшим котекстом работы (благодарности, библиография,...)

Опять же, у гуру Perl есть мудрость на эту тему:

> Уровень детализации в документации модуля Perl, как правило, идет от
> менее подробного к более подробному. Общий обзор (SYNOPSIS) должен
> cодержать минимальный пример использования (возможно, всего лишь одна строка
> кода; пропустить нетипичные случаи использования или что-нибудь не нужное большинству
> пользователей); Описание (DESCRIPTION) должно широко описать модуль,
> как правило, в несколько пунктов; более подробное описание процедур и методов модулей, длинные примеры кода,
или другие углубленные материалы должны быть приведены в последующих разделах.
>
> В идеале, некто, кто немного знаком с вашим модулем, должен быть
> способен освежить свою память без нажатия на клавишу "page down". Как ваш
> Читатели, изучающие ваш документ должен постепенно получать наибольшее количество знаний. -- из `perlmodstyle`


## [11] Забота о времени людей
Awesome; the ordering of these key elements should be decided by how quickly they let someone 'short circuit' and bail on your module.
Потрясающе; упорядочивание этих ключевых элементов должно определяться тем, насколько быстро они позволят кому-либо "перегореть" и разочароваться в вашем модуле.

Это звучит мрачно, не так ли? Но подумайте о следующем: ваша задача, тем более когда вы выполняете её с оптимальной
долей альтруизма, не в том, чтобы навязать людям свою работу. Ваша задача - позволить им наиболее объективно оценить то,
что ваше творение делает, и решить соотетствует это их требованиям или нет. А не, скажем, в увеличении скачиваний или пользовательской базы.

Такой тип мышления подходит не каждому; оно требует оставить в стороне ваше эго и позволить работе говорить самой за
себя как можно больше. Ваша единственная задача - описать это как можно кратко, чтобы искатели модулей могли использовать вашу работу, когда она походит, или переключиться на что-нибудь другое.

## [12] Бонус: другие хорошие практики

Вне ключевых моментов статьи, существуют и другие методы вы можете
следовать (или не следовать), чтобы поднять планку качества вашего README еще дальше, и
максимизировать свою полезность для других.

1. рассмотреть вопрос о включении ** ** Фон раздел, если ваш модуль зависит от того,
   важно, но не так широко известных абстракциями или других экосистем. Функция
   из [ `рассекает-between`] (https://github.com/noffle/bisecting-between) не
   сразу видно из его названия, поэтому она подробный * Фон * раздел
   определить и ссылку на больших понятий и абстракций нужно
   понимать и использовать его обращал внимания. Это также отличное место, чтобы объяснить
   мотивация модуля, если аналогичные модули уже существуют на НПМ.

2. Агрессивно linkify! Если говорить о других модулях, идей или людей, сделать
   что текст ссылки ссылку, так что посетители могут более легко обращал внимания на свой модуль
   и идеи он опирается. Немногие модули существуют в вакууме: вся работа идет
   от другой работы, поэтому он платит, чтобы помочь пользователям следовать за историю вашего модуля и
   вдохновение.

3. Включить информацию о типах аргументов и возвращаемых параметров, если это не
   очевидно. Предпочитают конвенции, где это возможно ( `cb`, вероятно, означает обратный вызов
   функция, `num`, вероятно, означает` Number`).

4. Включите пример кода в ** Использование ** в виде файла в вашем репо - может быть, как
   `Example.js`. Это здорово иметь README код, который пользователи могут реально работать, если
   они клонировать репозиторий.

5. Будьте рассудительным в вашем использовании значков. Они легко
   [Злоупотребление] (https://github.com/angular/angular). Они также могут быть питательной
   Основанием для bikeshedding и бесконечных споров. Они добавляют визуальный шум к вашему
   README, и как правило, только функция, если пользователь читает ваш уценки в
   браузер в Интернете, так как образы, как правило, размещается в другом месте на
   Интернет. Для каждого знака, рассмотреть следующие вопросы: "что реальное значение этот значок обеспечивая
   к типичным зрителем этого README "? Есть CI значок, чтобы показать сборки / тест
   положение дел? этот сигнал будет лучше добраться до важных партий по электронной почте
   Сопровождающие или автоматически создавая проблему - всегда считают
   аудитория данных в вашем README и спросите себя, если есть поток для
   что данные, которые могут лучше достичь своей целевой аудитории.

6. API форматирования является весьма bikesheddable. Используйте любой формат, который вы считаете наиболее
   ясно, но убедитесь, что ваш формат выражает важные тонкости:

   а. какие параметры не являются обязательными, и их значения по умолчанию

   б. говоря информацию о типе, где это не очевидно из конвенции

   гр. для `opts` параметров объекта, подробно описать все ключи и значения, которые принимаются

   d. не уклоняться от предоставления крошечный пример использования API функцию, если
      их использование не является очевидным или полностью покрыты в ** Использование ** раздела.
      Тем не менее, это также может быть сильным сигналом, что функция слишком сложна
      и должен быть переработан, разбиты на более мелкие функции, или удалены
      в целом

   е. агрессивно linkify специализированную терминологию! В уценки вы можете сохранить
      [Сноски] (https://daringfireball.net/projects/markdown/syntax#link) в
      в нижней части документа, поэтому обращаясь к ним несколько раз в течение
      становится дешевым. Некоторые из моих личных предпочтений по апи форматирования может быть
      найденный
      [Здесь] (https://github.com/noffle/common-readme/blob/master/api_formatting.md)

7. Если ваш модуль представляет собой небольшой набор функций без гражданства, имеющие
   ** Использование ** раздел как [Node РЕПЛ
   сессия] (https://github.com/noffle/bisecting-between#example) функции
   вызовы и результаты могут общаться использование более ясно, чем исходный код
   файл для запуска.

8. Если ваш модуль обеспечивает CLI (интерфейс командной строки) вместо (или в
    дополнение) программный API, показывают примеры использования в качестве командных вызовов
    и их вывод. если вы создаете или изменить файл, `cat` его, чтобы продемонстрировать
    изменение до и после.

9. Не забывайте использовать `package.json`
    [Ключевые слова] (https://docs.npmjs.com/files/package.json#keywords) направить
    модуль спелеологи к вашему порогу.

10. Чем больше вы изменить свой API, тем больше работы вам необходимо приложить обновления
    документация - Смысл заключается в том, что вы должны держать свои API,
    малого и конкретно определены на ранних стадиях. Требования изменяются с течением времени, но
    а не с фронтальной загрузкой допущений в API для ваших модулей, нагрузки
    их на один уровень абстракции: модуль поставил перед собой. Если требования
    * не делаем * изменение и "сделай один бетон-вещь" больше не имеет смысла, то просто
    написать новый модуль, который делает, что вам нужно. «Сделай одну конкретную вещь-'
    остается действительным и ценным модуль для НПМ экосистемы, и ваш курс
    коррекция не будет стоить вам ничего, кроме простой замены одного модуля для
    другой.

11. И, наконец, помните, что ваше хранилище управления версиями и ее
    встроенный README переживет свой [репозиторий хост] (https://github.com) и
    любой из вещей, которые вы гиперссылкой на - особенно изображений - так * * рядный ничего
    что имеет важное значение для будущих пользователей grokking свою работу.


## [13] Бонус: простое README

Не случайно, это также формат, используемый
[** Общего ридми **] (https://github.com/noffle/common-readme), набор README
руководящих принципов и генератор командной строки под рукой. Если вам нравится то, что здесь написано,
Вы можете сэкономить время на написание READMEs с `здравым readme`. Ты найдешь
реальные примеры модулей с этим форматом, тоже.


## [14] Призыв к оружию!

Идите вперед, храбрый модуль спелеолог, и сделать вашу работу обнаруживаемым и полезной
через отличную документацию!


## [15] Автор

Я [noffle] (http://blog.eight45.net/about/). Я, как известно,
[Блог] (http://blog.eight45.net), [чирикать] (https://twitter.com/noffle), и
[Хак] (https://github.com/noffle).

Этот маленький проект был начат еще в мае в Берлине в squatconf, где я был
копаться в том, как Perl монахи написали свою документацию, а также посетовал
состояние моих файлы README в узле экосистемы. Это побудило меня создать
[Общего ридми] (https://github.com/noffle/common-readme). "Ридми советы"
раздел разливалась с советами, хотя, который я решил было бы полезно собраны
в статье о написании READMEs. Таким образом, искусство README родился!


## [16] Сноски

1. <a name="footnote-1"> </a> Спасибо,
   [Sixes666] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8akpz6)!

1. <a name="footnote-2"> </a> Смотрите [The Jargon File] (http://catb.org/~esr/jargon/html/R/README-file.html).
   Тем не менее, большинство систем сегодня не будет сортировать столичными нижнем регистре
   символов, снижая полезность этой конвенции, чтобы только визуальный
   плакатное всех заглавных букв.


## [17] Благодарности

Искреннее спасибо [@mafintosh] (https://github.com/mafintosh) и
[@feross] (Https://github.com/feross) для поощрения мне нужно, чтобы получить эту
Идея с мертвой точки и начать писать!

Спасибо следующим удивительным читателям замечать ошибки и посылать мне
Реципиенты: сердце::

- [@ungoldman] (Https://github.com/ungoldman)
- [@boidolr] (Https://github.com/boidolr)
- [@imjoehaines] (Https://github.com/imjoehaines)
- [@radarhere] (Https://github.com/radarhere)
- [@joshmanders] (Https://github.com/joshmanders)
- [@ddbeck] (Https://github.com/ddbeck)
- [@StevenMaude] (Https://github.com/StevenMaude)

И спасибо моим читателям за их общей обратной связи:

- [Entiat_blues] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8am9w5)


## [18] Pull requests приветствуются!

Нашли ошибку? Где-то бессмыслица? Пришлите мне [pull request] (https://github.com/noffle/art-of-readme/pulls)!
