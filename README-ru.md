# Искусство README


## Происхождение

Как, когда и где появился термин "README"?

Первое упоминание относится к, как минимум, 1970-м годам [и
PDP-10](http://pdp-10.trailing-edge.com/decuslib10-04/01/43,50322/read.me.html),
хотя на самом деле, скорее отсылает нас в дни информативных бумажных заметок, возвышающихся
над стеком перфокарт, с нацарапанным "READ ME!" на них, описывавших использование этих перфокарт.

Читатель может предполодить<sup>[1](#footnote-1)</sup>, что название README может быть отсылкой к "Приключениям Алисы
в Стране Чудес" Льюиса Кэрола, где были бутылочка и пирог, с надписями "Выпей меня" и "Съешь меня" соответственно.

Надпись README, состоящая из всех заглавных букв является лишь одной из особенностей.
В дополнение к заметности самой фразы, написанной всеми заглавными буквами,
у такой надписи есть еще одна примечательная черта - UNIX-системы помещают слова, начинающиеся с заглавных букв,
наверх списка при сортировке. Таким образом, файл с названием README
(состоящим из всех заглавных букв), окажется в начале списка <sup>[2](#footnote-2)</sup>.

Посыл прост и понятен - это важная информация, с которой необходимо ознакомиться прежде,
чем продолжить работу. Давайте разберемся, что представляет собой "важная информация "в наш век информационных технологий.


## Для создателей, для потребителей

Это статья о файлах README. О том, что они делают, почему они так необходимы,
и как правильно их готовить.

Это написано для создателей различных модулей, ибо, как создатель модулей, ваша работа состоит в том, чтобы
создать что-то, что будет существовать долго и счастливо. Это должно быть вашей мотивацией, даже если вы, как автор,
не имеете никакого желания делиться своей работой. Пройдет полгода, и написанный вами модуль покажется вам совершенно
непонятным и незнакомым, просто потому, что человеку свойственно забывать неиспользуемую информацию.

Это важно и для тех, кто пользуется модулем. В конечном счете,
каждый автор чего-либо является и пользователем. Никто из нас не может
похвастаться абсолютной независимостью - мы все используем
в нашей работе что-то, уже созданное до нас.

Все вышесказанное верно для абсолютно всех языков программирования.


## Модули бывают разные: плохие и хорошие

Экосистема nodejs подпитывается своими модулями. [npm](https://npmjs.org) - это
магия, которая заставляет все это работать. В течение недели, разработчики оценивают
десятки модулей для включения их в свои проекты. Все вместе - очень мощный инструмент,
который может быть развернут и использован так же быстро, как вы напишете в консоли `npm install`.

Как и у любой экосистемы, которая является общедоступной, качество модулей может сильно варьироваться.
npm делает все возможное, чтобы все эти модули были доступны каждому. Тем не менее, эти инструменты
сильно разнятся: некоторые из них новые и отлично работают, другие не работают, а третьи
находятся где-то посередине. Есть и такие, о которых мы вообще не знаем, зачем они нужны.

Для модулей, это может принимать форму неточных или бесполезных
имен (кто нибудь может сказать, что делает модуль `fudge`?), отсутствия  документации,
тестов, отсутствие комментариев в исходном коде или непонятные имена функций.

Многие из них не имеют активного сопровождающего. Если модуль нет человека, способного
ответить на вопросы и объяснить, что делает модуль, в сочетании с отсутствием какой-либо
документация, модуль превращается в странный инопланетный артефакт, непригодный для использования и непонятный вообще никому.

А что касается тех модулей, у которых есть какая-нибудь документация? Может быть,
это просто описание в одну строку: `"числа сортируются по их шестнадцатиричному коду"`. Может быть, это фрагмент кода примера.
Это уже лучше чем ничего, но тоже приводит к худшему сценарию - копание в исходном коде,
с единственной целью - понять, как же все-таки оно работает.
Написание превосходной документации позволит не подпускать будущих пользователей к исходным
кодам, позволит им в полной мере насладиться удобством использования вашего модуля. А как оно устроено внутри -
им, пользователям, уже не важно.

Вся экосистема состоит из нескончаемого списка простых модулей, делающих одну единственную вещь, и никакую другую.
Есть [исключения](https://github.com/lodash/lodash), но они покрывают очень малую часть экосистемы.

Из этого следует простой вывод - найти действительно хороший модуль, который делает то,
что тебе нужно, может быть действительно сложной задачей.

И это нормально. Гораздо лучше иметь не очень высокую входную планку и понимание происходящего,
чем иметь очень маленькое сообщество, в жизни которого могут принимать участие единицы.

Плюс ко всему, чем непонятнее что-либо - тем важнее обратиться за помощью.


## Все дороги ведут к README.txt

Сообщество Nodejs ответило на вызов понятности различными способами.

Некоторые опытные разработчики на Nodejs объединились, чтобы создать
[рекомендованные  списки](https://github.com/sindresorhus/awesome-nodejs) качественных модулей.

Разработчики использовали их несколько лет, проверили сотни и тысячи модулей,
чтобы поделиться с новичками самыми сливками: в каждой категории только лучшие модули.
Это приняло форму RSS-ленты и e-mail рассылки со списками новых модулей, признаных
полезными различными опытными членами сообщества.

Как насчет социального графа? Эта идея привела к созданию
[node-modules.com](http://node-modules.com/), замене npm-поиска, которая
использует ваш социальный граф  на Github  чтобы найти модули, которые нравятся
вашим друзьям или были ими сделаны.

Конечно же есть и [поиск](https://npmjs.org), встроенный в npm:
безопасный и являющийся точкой входа для всех новых разработчиков.

Независимо от того какой подход вам больше нравится,
и не смотря на то где ищущий модули в конечном счете
находит себя: на [npmjs.org](https://npmjs.org) или
[github.com](https://github.com) или где-то еще,
абсолютно все будут читать ваш README. И раз уж до README все равно добрались,
то как сделать его максимально полезным для конечного пользователя?


## Ищите модули как профессионалы

### README: Ваш универсальный магазин

README - это первое, на что смотрит пользователь модуля - а, возможно, и последнее.
Потребитель хочет, чтобы модуль удовлетворил его потребности, так что вы должны доходчиво объяснить,
какие потребности закрывает ваш модуль и насколько эффективно он это делает.

Ваша задача заключается в:

1. рассказе о том, что есть из себя представляет ваш модуль(с контекстом)
2. показе того, как он работает
3. показе, как пользователи могут использовать его
4. рассказе о любых других сопутствующих деталях

Это *ваша* работа. Именно создатель модуля должен доказать, что его детище является
блестящим драгоценным камнем в море неподобающих модулей. Так как очень многие разработчики прежде всего будут
искать путь к вашему README, качество здесь - это оценка вашей работы перед лицом общественности.


### Краткость

Отсутствие README является мощнейшим красным флагом, но даже длинное README не
говорит о высоком качестве работы. Идеальный README должен быть настолько коротким, насколько
коротким он только может быть. Подробная документация хороша - сделайте отдельные
страницы для этого! - но сохраните ваш README лаконичным.


### Учитесь прошлым

Говорят, что те, кто не оглядывается назад, обречены повторять свои ошибки
снова и снова. Разработчики пишут документацию в течение некоторого количества
лет. Было бы расточительством не оглянуться немного назад и посмотреть, что люди
делали незадолго до Node.

Perl, со всей критикой, которая на него обрушивается, в некотором смысле является духовным прародителем
nodejs. Оба являются скриптовыми языками высокого уровня, принявшими многие идиомы UNIX, плотно
используются в интернете, и оба имеют широкую экосистему модулей.

Так получается, что [монахи](http://perlmonks.org) сообщества Perl
имеют большой опыт в написании
[качественных README](http://search.cpan.org/~kane/Archive-Tar/lib/Archive/Tar.pm).
CPAN - замечательный ресурс, который стоит прочитать, чтобы узнать больше о сообществе,
которое неуклонно пишет высококачественную документацию.


### Нет README? Нет абстракции

Отсутствие README означает что разработчикам нужно будет вникать в код для того, чтобы
понять его.

У [монахов из Perl](https://en.wikipedia.org/wiki/PerlMonks) есть мудрость касательно этого вопроса:

> Ваша документация будет полноценной, когда кто угодно сможет использовать ваш модуль без
> необходимости даже открывать его код. Это очень важно. Это даёт вам возможность отделить
> документированный интерфейс вашего модуля от его внутренней реализации. Это хорошо, 
> так как это означает, что вы можете свободно изменять "внутренности" модуля 
> в то время как интерфейс остается неизменным.
>
> Помните: документация, а не код, определяет то, что делает модуль. -- [Кен Уильямс](http://mathforum.org/ken/perl_modules.html#document)


### Ключевые элементы

После того, как обнаружится README, необходимо будет проанализировать его и определить,
соответствует ли модуль потребностям разработки. По сути, для мозга, это превращается в 
серию поисков по паттерну, где каждый шаг погружает всё глубже внутрь модуля и его детали.

Скажем, к примеру, мой поиск модуля обнаружения 2D столкновений  приводит меня к
[`collide-2d-aabb-aabb`](https://github.com/noffle/collide-2d-aabb-aabb).
Я начинаю рассматривать его сверху вниз:

1. *Имя* -- самоочевидные названия являются лучшими. `Collide-2d-aabb-aabb` звучит многообещающе,
   хотя это предполагает, что я знаю, что такое "aabb". Если имя звучит слишком
   расплывчато или несвязно, это может стать сигналом, чтобы двигаться дальше.

2. *В-одну-строку* -- наличие описания модуля "в-одну-строку" очень полезено для
   получения представления о том, что модуль делает в слегка подробных деталях.
   В `Collide-2d-aabb-aabb` говорится следующее

   > Определяет столкновение движущегося [параллельного осям ограничивающего прямоугольника] 
   >[https://ru.wikipedia.org/wiki/AABB](AABB) с другим AABB.

   Здорово: он определяет, что такое AABB, и то, что модуль делает. Идём дальше, чтобы оценить,
   насколько хорошо это впишется в мой код.

3. *Использование* -- прежде чем нырять с головой в API, было бы здорово увидеть модуль в действии. 
   Я могу быстро определить по JS примерам подходит ли это к желаемому стилю и проблеме.
   У людей есть много мнений на такие вещи, как обещания, обратные вызовы и ES6.
   Если это отвечает всем требованиям, то я могу перейти к более подробным деталям.

4. *API* -- название, описание и использование этого модуля заинтриговали меня.
   Я с большой вероятностью буду использовать этот модуль на этой стадии. Мне просто нужно просмотреть
   API для уверенности, что модуль делает именно то, что мне нужно, и что он легко сможет
   интегрироваться в мой код. Раздел API должен подробно рассказать про объекты и функции модуля,
   их подписи, типы возвращаемых значений, их вызовы и события. Типы должны быть указаны, если они не очевидны.
   Предостережения должны быть чётко разъяснены.

5. *Установка* -- если я дочитал до этого раздела, значит я решился опробовать этот модуль.
   Если есть нестандартные указания по установке, здесь им самое место. Но даже если это обычный `npm install`
   я хотел бы знать и об этом. Начинающие пользователи постоянно начинают использовать Node,
   так что наличие ссылки на [npmjs](https://www.npmjs.com/) и примеры команд установки помогает таким
   пользователям разобраться как работают модули Node.

6. *Лицензия* -- большинство модулей размещают этот раздел в самом низу, но, наверное, лучше
   переместить его в самый верх. Вы, скорее всего, исключите модуль ОЧЕНЬ быстро, если он имеет
   несовместимую лицензию с вашей работой. Я вообще придерживаюсь букета из MIT / BSD / X11 / ISC. 
   Если у вас есть не рекомендованная лицензия, прикрепите её в самый верх модуля, чтобы предотвратить путаницу.


## [10] Когнитивная утекают

Упорядочение выше, не был выбран случайным образом.

потребители модулей используют множество модулей, и нужно смотреть на многих модулей.

После того, как вы посмотрели на сотни модулей вы начинаете замечать, что ум
выгоды от предсказуемый характер.

Вы также начать строить свой собственный личный эвристики для какую информацию вы
хотите, и какие красные флаги дисквалифицировать модули быстро.

Таким образом, отсюда следует, что в README желательно иметь:

1. предсказуемый формат
2. некоторые ключевые элементы присутствуют

Вам не нужно использовать * этот формат *, но стараюсь быть последовательным, чтобы сохранить пользователей
драгоценные познавательные циклы.

Упорядочение представленная здесь любовно называют "когнитивным утекают",
и можно представить себе в виде воронки в вертикальном положении, где самый широкий конец содержит
Широчайшие более важные детали, и перемещение глубже в воронку подарки
более конкретные детали, которые уместны только для читателя, который интересуется
достаточно в своей работе, что глубоко, что достигнуто в документе. И, наконец,
дно может быть зарезервирован для деталей, которые только те, заинтригованы тем глубже
контекст работы (фон, кредиты, Библио, ...)

Опять же, монахи Perl есть мудрость, чтобы делиться на эту тему:

> Уровень детализации в документации модуля Perl как правило, идет от
> Менее подробные, чтобы более детально. Ваш СИНТАКСИС раздел должен
> Содержит минимальный пример использования (возможно, всего лишь одной линии
> Код; пропустить необычные случаи использования или что-нибудь не нужны большинством
> пользователей); Описание должно описать свой модуль в широком смысле,
> Как правило, в несколько пунктов; более подробно модуля
> процедуры или методы, длинные примеры кода, или другие в глубины
> Материал должен быть приведен в последующих разделах.
>
> В идеале, кто-то, кто немного знаком с модулем должен быть
> Возможность освежить в памяти без нажатия на клавишу "страницу вниз". Как ваш
> Читатель продолжает через документ, они должны получать
> Прогрессивно большее количество знаний. - От `perlmodstyle`


## [11] Забота о времени людей

Потрясающие; упорядочение этих ключевых элементов должны определяться, как быстро
они позволяют кому-то «короткое замыкание» и под залог Вашего модуля.

Это звучит мрачно, не так ли? Но думать об этом: ваша работа, когда вы делаете
она с оптимальным альтруизма в виду, не "продать" людей на работе. Это в
пусть оценить то, что ваше творение делает настолько объективно, насколько это возможно, и решить,
отвечает ли она их потребности или нет. Не, скажем, увеличить ваши загрузки или
UserBase.

Такое мышление не обращается к каждому; она требует проверки вашего эго на
дверь и позволить работу говорить за себя как можно больше. Ваша единственная работа
чтобы описать свое обещание, как сжато, как вы можете, так что модуль спелеологи может
либо использовать вашу работу, когда это нужным, или двигаться дальше к чему-то другому, что делает.

## Всем ридми!

Теперь идите и напишите ридми на все ваши модули,
сделайте вашу работу понятной и доступной с помощью отлично написанной документации!

## Бонус: другие хорошие практики

Кроме ключевых аспектов данной статьи, существует еще много годных практик, которые вы
можете применять чтобы отодвинуть ползунок полезности вашего README для сообщества к максимуму.

1. Рассмотрите возможность включения раздела **"Исходные данные"**, если ваш модуль зависит
от очень важных, но не сильно распространенных абстракций или других экосистем.
Назначение функции [`bisecting-between`](https://github.com/noffle/bisecting-between) не сразу
понятно из названия. Поэтому она имеет раздел "Исходные данные" с подробной информацией и ссылками
на основополагающие концепты и абстракции.
Также это неплохое место чтобы объяснить, что подтолкнуло автора к написанию данной функции, если таковая уже есть в npm.

2. Вставляйте ссылки! Если вы, описывая свой модуль, говорите о других модулях, людях или идеях,
всегда делайте умоминания кликабельными. Это позволит проще вникнуть в суть в вашего модуля и легко
перейти к той или иной ссылке. Очень немногие модули существуют в вакууме: любая работа начинается
с другой работы. Помогите людям понять историю вашего модуля и то, чем он было мотивировано его создание.

3. Включить информацию о типах аргументов и возвращаемых значений , если это не очевидно.
Отдавайте предпочтение общеиспользуемым соглашениям (`cb`, вероятно, означает callback функцию, `num` -- ` Number`).

4. Включите пример кода из раздела **Использование** в виде файла в вашем репозитарии - что-то вроде
`example.js`. Это очень здорово иметь "README" код, который пользователи могут запустить, сразу после клонирования репозитория.

5. Будьте благоразумными при использовании значков.
Ими очень легко [злоупотребить](https://github.com/angular/angular).
Также они могут стать почвой для отхода от сути и постоянных споров.
Они добавляют визуальный шум к вашему README, и как правило, работают только, если пользователь читает ваш
markdown в браузере онлайн, так как картинки, как правило, размещаются где-нибудь в интернете.
Для каждого значка, спросите себя: "какую реальную пользу принесет этот значок для типичного читателя README?"
Имеется ли CI виджет для показа статуса сборки/тестов?
эта вещь лучше достанет важных участников через email или автоматически создаст issue -- всегда имейте
ввиду целевую аудиторию для данных в вашем README и спрашивайте себя, есть
ли еще данные, которые смогут быть полезны для аудитории

6. Оформление API отвлекает от сути. Используйте любой формат, который вы считаете наиболее
   понятным, но убедитесь, что ваш формат отражает важные особенности:

   a. какие параметры не являются обязательными, и их значения по умолчанию

   b. упомяните информацию о типе, где это не очевидно из соглашений

   c. для `opts` параметров объекта, подробно описывайте все ключи и значения, которые они принимают

   d. не уклоняйтесь от предоставления небольших примеров использования функции API, если
      их использование не очевидно или не полностью разъяснено в разделе **Использование**.
      Также это может быть явным показателем, что функция излишне сложная и должен быть отрефакторена,
      разбита на более мелкие функции, или удалена вовсе.

   e. делайте ссылки на специализированную терминологию! В markdown вы можете держать
      [сноски](https://daringfireball.net/projects/markdown/syntax#link) в
      в нижней части документа, поэтому обращение к ним несколько раз в документе
      становится очень простым. Некоторые из моих личных предпочтений по описанию
      API находятся [здесь](https://github.com/noffle/common-readme/blob/master/api_formatting.md)

7. Если ваш модуль представляет собой набор отдельных функций, то оформление раздела **Использование** 
в виде [сессии интерпретатора node](https://github.com/noffle/bisecting-between#example) с
примерами вызова функции и возвращаемыми данными, может предомонстрировать использование
модуля более ясно, чем отдельный файл с примерами.

8. Если ваш модуль предоставляет CLI (интерфейс командной строки) вместо (или в дополнение)
к программному API, делайте примеры использования, использую вызовы командной строки и их вывод.
Если вы создаете или изменяете файл, делайте на него `cat`, чтобы продемонстрировать изменение до и после.

9. Не забывайте про [ключевые слова](https://docs.npmjs.com/files/package.json#keywords)
в вашем `package.json`. Они помогут найти ваш модуль.

10. Чем сильнее вы измените свое API, тем больше работы вам необходимо будет приложить
для обновления документации - смысл здесь в том, что вы должны держать свои API небольшими
и конкретно определенными на ранних стадиях.
Требования постепенно меняются, и вместо того, чтобы каждый раз добавлять изменения в API
вашего модуля, лучше помещайте их на один уровень абстракции - напрямую в сам модуль.
Если требования меняются и "делать одну конкретную вещь" более не имеет смысла, тогда
просто напишите новый модуль, который будет делать то, что вам нужно.
Принцип "делать одну конкретную вещь" оставляет модуль правильным и полезным для экосистемы
npm и изменения курса не стоит вам ровным счетом ничего, кроме создания простой зависимости одного модуля от другого.

11. И, наконец, помните, что ваш репозитарий и включенный в него файл README покинет свой
[родной дом](https://github.com) как и все то, на что вы делали гиперссылки - особенно
изображения - так что *встраивайте внутрь* все то, что имеет важное значение для будущих пользователей вашего детища.


## Бонус: простое README

Не секрет, что это также формат, используемый в
[**common-readme**](https://github.com/noffle/common-readme), набор правил для написания README
и генератор, работающий в командной строке. Если вам нравится то, что здесь написано,
вы можете сэкономить время на написание своих README-шек с помощью `common-readme`. Здесь же можно найти примеры
реальных ридми, написанных в этом формате.

Вам также может понравится
[standard-readme](https://github.com/richardlitt/standard-readme). Оно является
более структурированным и проверяемым приемником формата common README.


## Бонус: примеры

Теория - это хорошо, но как же выглядят превосходные README? Здесь я представил некоторые README,
которые как мне кажется соответствуют принципам данной статьи:

- https://github.com/feross/bittorrent-dht
- https://github.com/freeman-lab/pixel-grid
- https://github.com/mafintosh/torrent-stream
- https://github.com/mikolalysenko/box-intersect
- https://github.com/noffle/ice-box
- https://github.com/pull-stream/pull-stream
- https://github.com/substack/tape
- https://github.com/substack/quote-stream
- https://github.com/yoshuawuyts/vmd


Если вы знаете другие README, которые могут послужить хорошим примером,
[отправляйте pull request](https://github.com/noffle/art-of-readme/pulls)!


## Бонус: README чеклист

Удобный и добросовестный чеклист, которые покажет, что представляет из себя ваше README:

- [ ] Описание цели вашего модуля в одну строку
- [ ] Обязательное указание исходных данных и ссылок
- [ ] Ссылки на объяснение по всем потенциально непонятным терминам
- [ ] Понятные и *готовые к запуску* примеры использования
- [ ] Инструкция по установке
- [ ] Расширенная документация API
- [ ] Performs [cognitive funneling](https://github.com/noffle/art-of-readme#cognitive-funneling)
- [ ] Предостережения и ограничения
- [ ] Не найдейтесь на изображения при объяснении критичной информации
- [ ] Лицензия


## Об авторе

Я -  [noffle] (http://blog.eight45.net/about/). [Мой блог] (http://blog.eight45.net),
[мой твиттер] (https://twitter.com/noffle), и [мой код] (https://github.com/noffle).

Этот маленький проект был начат еще в мае в Берлине на конференции squatconf, где я разбирался,
как "старички" Perl-а пишут свою документацию, а также сокрушался из-за состояния
моих собственных README в Node. Это побудило меня создать
[common-readme] (https://github.com/noffle/common-readme). Раздел "Советы по README"
был переполнен и я решил, что будет полезно собрать их всех в статью о том, как писать ридми.
Так появилось "Искусство README".


## Сноски

1. <a name="footnote-1"> </a> Спасибо,
   [Sixes666] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8akpz6)!

1. <a name="footnote-2"> </a> Смотрите [The Jargon File] (http://catb.org/~esr/jargon/html/R/README-file.html).
   Тем не менее, большинство систем сегодня не будет сортировать столичными нижнем регистре
   символов, снижая полезность этой конвенции, чтобы только визуальный
   плакатное всех заглавных букв.


## Благодарности

Выражаю благодарность [@mafintosh] (https://github.com/mafintosh) и
[@feross] (Https://github.com/feross), которые подтолкнули меня написать эту статью
и сдвинули дело с мертвой точки.

Спасибо следующим удивительным читателям за то, что помогали исправлять ошибки
и посылать мне PR-ы :heart: :

- [@ungoldman] (Https://github.com/ungoldman)
- [@boidolr] (Https://github.com/boidolr)
- [@imjoehaines] (Https://github.com/imjoehaines)
- [@radarhere] (Https://github.com/radarhere)
- [@joshmanders] (Https://github.com/joshmanders)
- [@ddbeck] (Https://github.com/ddbeck)
- [@StevenMaude] (Https://github.com/StevenMaude)

И спасибо моим читателям за их отзывы:

- [entiat_blues] (https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8am9w5)


## Перевод

Команда энтузиастов-переводчиков, рискнувших перевести эту статью:

- [@sapunovnik] (https://github.com/Sapunov)
- [@cheburashka21] (https://github.com/IvanGamazov)
- [@skyrocker] (https://github.com/chulanovskyi)
- [@foromik] (https://github.com/FoRomik)
- [@wladyslaw] (https://github.com/vlshat)


## Pull request-ы приветствуются!

Нашли ошибку в переводе? Что-то непонятно? Пришлите мне
[pull-request] (https://github.com/Sapunov/art-of-readme/pulls)!


## Лицензия

[Creative Commons Attribution License](http://creativecommons.org/licenses/by/2.0/)
